<!DOCTYPE html>
<html lang="ru">
<head>
	<title>Безопасность web-приложений, архитектура web-приложений и разработка API, тестирование компонент</title>
	<meta charset="utf-8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<script>
		'use strict';

		const gcd = (a, b) => (b === 0) ? a : gcd(b, a % b);
		const w = screen.width;
		const h = screen.height;
		const r = gcd(w, h);

		console.log(`${w}x${h}`);
		let aspect = `${w / r}x${h / r}`;
		console.log(aspect);

		const ratios = ['8x5', '4x3', '6x5', '5x3', '5x4', '16x9'];
		if (!ratios.includes(aspect)) {
			aspect = ratios[0];
		}

		if (['localhost', '127.0.0.1'].includes(window.location.hostname)) {
			aspect = '4x3';
		}
		aspect = '4x3';

		document.write(`<link rel="stylesheet" href="/lib/shower/themes/technopark/styles/screen-${aspect}.css">`);

	</script>

	<link rel="stylesheet" href="/lib/hljs/styles/github.css">
	<link rel="stylesheet" href="/lib/slides.css">

</head>
<body class="shower list">

<header class="caption">
	<h1>Безопасность web-приложений, архитектура web-приложений и разработка API, тестирование компонент</h1>
	<p>Технопарк, осень, 2017 г.</p>
</header>

<section class="slide first">
	<h2 class="shout">Безопасность web-приложений<br/>
		<small>Слайды доступны по ссылке<br/>
			<a href="https://frontend-park-mailru.firebaseapp.com/">frontend-park-mailru.firebaseapp.com</a>
		</small>
	</h2>
</section>

<section class="slide">
	<h2>Same Origin Policy</h2>
	<blockquote>
		<p class="medium-content"><b>Правило ограничения домена (Same Origin Policy &mdash; «Принцип одинакового
			источника»)</b> &mdash; это важная концепция безопасности и работы web-приложений. Она призвана
			<mark>ограничивать возможности</mark>
			пользовательских сценариев из определённого источника по доступу к ресурсам и информации из других
			источников
		</p>
	</blockquote>
</section>

<section class="slide">
	<h2>Same Origin Policy</h2>
	<p>Вводится понятие
		<mark>источника</mark>
		(адрес в интернете, откуда был загружен ресурс). Два URL считаются имеющим один источник («same origin»), если у
		них
		<mark>одинаковый протокол, домен и порт</mark>
	</p>
	<p>У этих ресурсов одинаковые источники:</p>
	<ul>
		<li><code>http://site.com</code></li>
		<li><code>http://site.com/</code></li>
		<li><code>http://site.com/my/page.html</code></li>
	</ul>
</section>

<section class="slide">
	<h2>Same Origin Policy</h2>
	<p>У этих ресурсов <strong>разные</strong> источники:</p>
	<ul>
		<li><code>http://site.com</code></li>
		<li><code>http://<strong>www</strong>.site.com</code> (другой домен)</li>
		<li><code>http://site.<strong>org</strong></code> (другой домен)</li>
		<li><code><strong>https</strong>://site.com</code> (другой протокол)</li>
		<li><code>http://site.com:<strong>8080</strong></code> (другой порт)</li>
	</ul>
</section>

<section class="slide question">
	<h2><span style="font-size: 65%">Как именно это помогает обеспечить <mark>безопасность</mark> web-приложений?</span>
	</h2>
</section>

<section class="slide">
	<h2>Элемент <code>&lt;iframe></code></h2>
	<blockquote>
		<p class="medium-content">Элемент <code>&lt;iframe></code> создаёт фрейм &mdash; область заданных размеров,
			которая находится внутри обычного документа, в которую можно загружать любые другие независимые документы
		</p>
	</blockquote>
</section>

<section class="slide">
	<h2>Элемент <code>&lt;iframe></code></h2>
	<code>&lt;iframe src="https://www.w3.org/" width="900" height="300"></code>

	<iframe src="https://www.w3.org/" frameborder="0" id="frameMy" width="900" height="310"></iframe>
</section>

<section class="slide">
	<h2>Cross Origin HTTP-запросы (
		<mark>XHR</mark>
		)
	</h2>
	<pre class="hljs js">
			<code><span class="comment rus">// Находимся на https://evil.com/</span></code>
			<code>const xhr = new XMLHttpRequest();</code>
			<code>xhr.open('GET', <mark>'https://e.mail.ru/messages/inbox/'</mark>, false);</code>
			<code>xhr.send();</code>
			<code> </code>
			<code>console.log(xhr.responseText)</code>
			<code> </code>
		</pre>
</section>

<section class="slide question">
	<h2><span style="font-size: 85%">Архитектура наших приложений?</span></h2>
</section>

<section class="slide">
	<h2>Архитектура наших приложений?</h2>
	<div style="position:relative;width: 100%; height: 75%;">
		<img class="place" src="arch.png" style="transform-origin: center;transform: translate(-50.45%,-51%) scale(.893);">
	</div>
</section>

<section class="slide">
	<h2>Когда отправляются запросы?</h2>
	<p class="small-content"></p>
	<ul>
		<li>При загрузке ресурсов (элементы <code>&lt;img></code>, <code>&lt;script></code>)</li>
		<li>При отправке форм (форму можно сабмитить с двумя методами: GET и POST)</li>
		<li>С помощью JavaScript (XHR, fetch)</li>
	</ul>
</section>

<section class="slide">
	<h2>HTTP access control (CORS)</h2>
	<blockquote>
		<p class="small-content"><b>Cross-Origin Resource Sharing (CORS) standard</b> &mdash; спецификация,
			накладывающая ограничения на запросы такого типа (работает по принципам Same Origin Policy). Появилась
			относительно недавно</p>
	</blockquote>
</section>

<section class="slide">
	<h2>Запросы делятся на два типа</h2>
	<p>Простыми считаются запросы, если они удовлетворяют следующим двум условиям:</p>
	<ul>
		<li>Простой метод: GET, POST или HEAD</li>
		<li>Простые заголовки &mdash; только из списка:
			<ul>
				<li><code>Accept</code></li>
				<li><code>Accept-Language</code></li>
				<li><code>Content-Language</code></li>
				<li><code>Content-Type</code></li>
			</ul>
		</li>
	</ul>
</section>

<section class="slide">
	<h2>Запросы делятся на два типа</h2>
	<p class="small-content">Остальные запросы считаются
		<mark>"непростыми"</mark>
		, и при отправке таких запросов необходимо понять, согласен ли сервер на обработку таких запросов. Эти запросы
		всегда отсылаются со специальным заголовком <code>Origin</code></p>
</section>

<section class="slide">
	<h2>CORS для простых запросов</h2>
	<pre class="hljs http">
			<code>GET /data HTTP/1.1</code>
			<code>Host: e.mail.ru</code>
			<code>Origin: http://frontend.tech-mail.ru</code>
			<code> </code>
		</pre>
	<pre class="hljs http">
			<code>HTTP/1.1 200 OK</code>
			<code>Content-Type: text/html; charset=UTF-8</code>
			<code><mark>Access-Control-Allow-Origin:</mark> http://frontend.tech-mail.ru</code>
			<code><span class="comment">// Access-Control-Allow-Origin: *</span></code>
			<code> </code>
		</pre>
</section>

<section class="slide">
	<h2>CORS для простых запросов:<br/>дополнительные заголовки</h2>
	<pre class="hljs http">
			<code>HTTP/1.1 200 OK</code>
			<code>Content-Type: text/html; charset=UTF-8</code>
			<code>Access-Control-Allow-Origin: http://frontend.tech-mail.ru</code>
			<code>...</code>
			<code>X-UID: 42</code>
			<code>X-Secret: 2c9de507f2c54aa1</code>
			<code><mark>Access-Control-Expose-Headers:</mark> X-Uid, X-Authentication</code>
			<code> </code>
		</pre>
</section>

<section class="slide">
	<h2>CORS для простых запросов:<br/>данные авторизации</h2>
	<pre class="hljs js">
			<code>const xhr = new XMLHttpRequest();</code>
			<code>xhr.<mark>withCredentials</mark> = true;</code>
			<code>xhr.open('GET', 'https://e.mail.ru/messages/inbox/', false);</code>
			<code> </code>
		</pre>
	<pre class="hljs http">
			<code>HTTP/1.1 200 OK</code>
			<code>Content-Type: text/html; charset=UTF-8</code>
			<code>Access-Control-Allow-Origin: <mark>domain</mark> <span class="comment">// '*' запрещено</span></code>
			<code><mark>Access-Control-Allow-Credentials:</mark> true</code>
			<code> </code>
		</pre>
</section>

<section class="slide">
	<h2>"Непростые" запросы</h2>
	<p>При отправке "непростого" запроса, браузер сделает на самом деле <strong>два</strong> HTTP-запроса.
	<ul>
		<li>«Предзапрос» (английский термин «preflight») OPTIONS. Cодержит название желаемого метода в заголовке <code>Access-Control-Request-Method</code>,
			а если добавлены особые заголовки, то и их тоже &mdash; в <code>Access-Control-Request-Headers</code>.
		</li>
		<li>Основной HTTP-запрос с заголовком <code>Origin</code></li>
	</ul>
</section>

<section class="slide">
	<h2>"Непростые" запросы</h2>
	<p>Ответ на предзапрос может содержать следующие заголовки</p>
	<pre class="hljs http">
			<code>HTTP/1.1 200 OK</code>
			<code>Content-Type: text/plain</code>
			<code><mark>Access-Control-Allow-Methods:</mark> DELETE, PUT, HEAD, OPTIONS, GET, POST</code>
			<code><mark>Access-Control-Allow-Headers:</mark> Content-Type, User-Agent ...</code>
			<code>         ... X-Requested-With, If-Modified-Since, Cache-Control</code>
			<code><mark>Access-Control-Max-Age:</mark> 86400</code>
			<code> </code>
		</pre>
</section>


<!--закончили с Безопасностью-->


<section class="slide">
	<h2 class="shout">Работа с API</h2>
</section>

<section class="slide">
	<h2>Что есть
		<mark>API</mark>
	</h2>
	<blockquote>
		<p class="medium-content"><b>API (application programming interface, интерфейс программирования приложений)</b>
			&mdash; набор готовых классов, процедур, функций, структур и констант, предоставляемых приложением
			(библиотекой, сервисом) или операционной системой для использования во внешних программных продуктах.
			Используется программистами при написании всевозможных приложений</p>
	</blockquote>
</section>

<section class="slide">
	<h2>Что есть
		<mark>API</mark>
	</h2>
	<p>API определяет
		<mark>функциональность</mark>
		, которую предоставляет программа (модуль, библиотека), при этом API позволяет абстрагироваться от того, как
		именно эта функциональность реализована
	</p>
	<p><b>Web API</b> &mdash; используется в веб-разработке, как правило, определённый набор HTTP-запросов, а также
		определение
		<mark>структуры</mark>
		HTTP-ответов, для выражения которых используют XML или JSON форматы
	</p>
</section>

<section class="slide">
	<h2>Сема́нтика</h2>
	<blockquote>
		<p><b>Сема́нтика</b> &mdash; раздел лингвистики, изучающий смысловое значение единиц языка</p>
	</blockquote>
	<p><br/>
		&ndash; <em>Работодатель:</em> Назовите вашу главную слабость <br/>
		&ndash; <em>Кандидат:</em> Я даю
		<mark>семантически</mark>
		корректные, но практически неприменимые ответы на вопросы <br/>
		&ndash; <em>Работодатель:</em> Могли бы вы привести пример? <br/>
		&ndash; <em>Кандидат:</em> Да, мог бы
	</p>
</section>

<section class="slide">
	<h2>CRUD</h2>
	<blockquote>
		<p><b>CRUD (create, read, update, delete)</b> &mdash; акроним, обозначающий четыре базовые функции, используемые
			при работе с персистентными хранилищами данных, описывает семантику методов HTTP</p>
	</blockquote>
	<ul>
		<li>GET (чтение данных)</li>
		<li>POST (создание данных)</li>
		<li>PUT (полное обновление данных) или PATCH (частичное обновление данных)</li>
		<li>DELETE (удаление данных)</li>
		<li>HEAD запрашивает ресурс так же, как и GET, но без тела ответа</li>
		<li>OPTIONS используется для описания параметров соединения с ресурсом</li>
	</ul>
</section>

<section class="slide">
	<h2>REST</h2>
	<blockquote>
		<p><b>REST (в применении к именованию ресурсов)</b> &mdash; набор методик и практик, которые используются для
			именования ресурсов, с которыми работает система</p>
	</blockquote>
	<p>Все типы ресурсов делятся на две категории:</p>
	<ul>
		<li>
			<mark>коллекции ресурсов</mark> &mdash; имеют имя
		</li>
		<li>
			<mark>отдельные представители</mark> &mdash; принадлежат к какой-то коллекции и имеют идентификатор, чтобы
			отличать различных представителей коллекции друг от друга
		</li>
	</ul>
</section>

<section class="slide">
	<h2>REST</h2>
	<p>Коллекция книг (books):</p>
	<ul>
		<li>Вся коллекция получает URI <code>/books</code></li>
		<li>Идентификатор книги &mdash; её ISBN. Отдельные книги:
			<ul>
				<li><code>/books/2-266-11156-6</code></li>
				<li><code>/books/3-720-55486-7</code></li>
				<li><code>/books/1-054-55901-2</code></li>
			</ul>
		</li>
	</ul>
</section>

<section class="slide">
	<h2>REST</h2>
	<p>Коллекция пользователей (users):</p>
	<ul>
		<li>Вся коллекция получает URI <code>/users</code></li>
		<li>Идентификатор пользователя &mdash; его ID. Отдельные пользователи:
			<ul>
				<li><code>/users/id2</code></li>
				<li><code>/users/id432</code></li>
				<li><code>/users/id1211177181</code></li>
			</ul>
		</li>
	</ul>
</section>

<section class="slide">
	<h2>REST + CRUD = семантическое API</h2>
	<pre class="hljs http">
			<code>Получение всех книг</code>
			<code>GET /books HTTP/1.1</code>
			<code>Host: awesome.com</code>
			<code> </code>
			<code>Получение конкретной книги</code>
			<code>GET /books/3-720-55486-7 HTTP/1.1</code>
			<code>Host: awesome.com</code>
			<code> </code>
			<code>Удаление конкретной книги</code>
			<code>DELETE /books/3-720-55486-7 HTTP/1.1</code>
			<code>Host: awesome.com</code>
			<code> </code>
		</pre>
</section>

<section class="slide">
	<h2>Документирование API</h2>
	<p class="small-content"></p>
	<ul>
		<li><a href="http://swagger.io/" target="_blank">swagger</a></li>
		<li><a href="https://apiary.io/" target="_blank">apiary</a></li>
		<li><a href="https://apiblueprint.org/" target="_blank">apiblueprint</a></li>
		<li>Ваши варианты ;)</li>
	</ul>
</section>


<!--закончили с API-->


<section class="slide">
	<h2 class="shout">Promise и<br/>Fetch API</h2>
</section>


<section class="slide">
	<h2>План лекции</h2>
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%; font-size: 150%;">
		<ol>
			<li>Асинхронность и проблемы</li>
			<li>Промисы</li>
			<li>Fetch API</li>
			<li>Обработка исключений</li>
			<li>Тестирование</li>
		</ol>
	</div>
</section>

<section class="slide question">
	<!--
	прежде чем говорить о промисах и прочей ерунде
	надо рассказать о том что такое callback hell
	или более широкое понятие pyramid of doom.

	Не тот Doom который лучше чем DOM.
	-->
	<h2>
		<span style="font-size: 85%"><mark>Callback Hell</mark> или <mark>Pyramid of Doom</mark>?</span>
	</h2>
</section>

<section class="slide">
	<!--
	вспомним о том что такое callback-и

	функции могут возвращать результат естественным путем
	функции могут возвращать результат через callback (когда мы работаем с асинхронным кодом)

	callback это функция которую мы передаем в другую функцию чтобы та в свою очередь вызвала

	из-за этой особенности многим трудно понимать код на JS:
	код выполняется не сверху вниз а фиг пойми как

	например на слайде нижнее сообщение выполнится первым

	это сделано не просто так а ради неблокирующих операций IO

	асинхронность в JS это сила а не слабость, но за всё надо платить

	но какой код мы напишем если после первой операции
	нам нужно будет сделать еще одну асинхронную и вывести результат?
	-->
	<h2>Callback Hell или Pyramid of Doom</h2>
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%;">
		<pre class="hljs js">
			<code>// Делаем что-нибудь асинхронное </code>
			<code>doSomethingAsync(function() { </code>
			<code>	// callback </code>
			<code>	console.log('Получилось!!!11'); </code>
			<code>}); </code>
			<code>console.log('Еще пока не получилось :-('); </code>
		</pre>
	</div>
</section>

<section class="slide">
	<!--
	скорей всего мы просто добавим её вызов в наш callback
	финальный console.log вынесем в новый callback

	а что если нам нужен еще один вызов? или if вставить?
	-->
	<h2>Callback Hell или Pyramid of Doom</h2>
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%;">
		<pre class="hljs js">
			<code>// Делаем что-нибудь асинхронное</code>
			<code>doSomethingAsync(function() {</code>
			<code>	// Делаем что-нибудь еще </code>
			<code>	// очень важное и асинхронное</code>
			<code>	doSomethingElse(function() {</code>
			<code>		// callback</code>
			<code>		console.log('Получилось!!!11');</code>
			<code>	});</code>
			<code>});</code>
		</pre>
	</div>
</section>

<section class="slide">
	<!--
	будет так

	это и называется callback hell или pyramid of doom

	пирамида потому-что пирамида
	callback hell потому что это callback-и и это ад

	т.е. суть в том когда код растет вправо быстрей чем вниз

	надеюсь не надо объяснять почему это плохо
	тех кому это не понятно понимание настигнет само,
	главное больше так писать

	-->
	<h2>Callback Hell или Pyramid of Doom</h2>
	<img class="place" src="callbackHell.png">
</section>

<section class="slide">
	<h2>Избавляемся от пирамид</h2>
	<!--
	как только мы осознали что пирамиды это плохо
	хочется от них избавиться

	сделать это можно например так:

	выносим колбеки как отдельные функции
	придумываем адекватные названия

	расположить их при этом можно в порядке выполненения (JS это позволяет)
	или по старинке следуя правилу "не использовать до объявления"

	пирамид больше нет но callback-и остались
	-->
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%;">
		<pre class="hljs js">
<code>
// Делаем что-нибудь асинхронное
doSomethingAsync(step1);

function step1() {
	// Делаем что-нибудь еще
	// очень важное и асинхронное
	doSomethingElse(step2);
}

function step2() {
	console.log('Получилось!!!11');
}
</code>
		</pre>
	</div>
</section>

<!--



-->

<section class="slide">
	<!--
	рассказ про то когда и зачем придумали Promise
	-->
	<h2>Futures или Promise</h2>
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%;">
		<p>
			Термин <mark>promise</mark> был предложен в 1976 году Дэниэлом Фридманом и Дэвидом Вайзом,
			а Питер Хиббард назвал его <mark>eventual</mark>.
			Похожая концепция под названием <mark>future</mark> была предложена в 1977 году
			в статье Генри Бейкера и Карла Хьюитта.
		</p>
	</div>
</section>

<section class="slide">
	<!--
	В переводе с иностранного "Promise" означет "Обещание".

	Аналогия про вопросы о времени:
	- Я могу спросить кого-нибудь о том который час - это "синхронный" вызов
	- Я могу попросить сказать мне когда пройдет 5 минут - это будет "callback"
	- Я могу попросить а затем сказать всем что этот человек ОБЕЩАЛ
	  сказать когда пройдет 5 минут - обещание

	Т.е. обещание это отдельная сущность, которой можно поделиться с другими
	-->
	<h2>Что такое Promise?</h2>
	<img class="place" src="promise.jpg" height="500">
</section>

<section class="slide">
	<!--
	Что же такое Promise в JS?

	Рассказываю определение своими словами

	МММ?

	Функция теперь возвращает результат естественным путем
	-->
	<h2>Что такое Promise?</h2>
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%;">
		<blockquote>
			<p><b>
				Интерфейс <mark>Promise</mark> (обещание) представляет собой обертку для значения, неизвестного на
				момент создания обещания.
			</b></p>
			<p>
				Он позволяет обрабатывать результаты асинхронных операций так,
				как если бы они были синхронными: вместо конечного результата асинхронного метода
				возвращается обещание получить результат в некоторый момент в будущем.
			</p>
		</blockquote>
	</div>
</section>

<section class="slide">
	<!--
		Рассказываю по слайду своими словами
	-->
	<h2>Что такое Promise?</h2>
	<p>
		Основной способ взаимодействия с промисом это использование его метода <mark>then</mark>,
		регистрирующего функции обратного вызова для получения конечного результата промиса
		или сообщения о причине, по которой он не был выполнен.
	</p>
	<pre class="hljs js" style="margin-top: -50px;">
		<code>
			const promise = new Promise( ... );

			promise.then(function(value) {
				// Обработчик успешного выполнения обещания
				// Принимает значение обещания
			}, function(error) {
				// Обработчик ошибки при выполнении обещания
				// Принимает ошибку (исключение)
			});
		</code>
	</pre>
</section>

<section class="slide">
	<!--
	Если вспомнить наш самый первый пример,
	то с промисами он будет выглядеть так:
	-->
	<h2>Что такое Promise?</h2>
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%;">
		<pre class="hljs js">
<code>
// Делаем что-нибудь асинхронное
const promise = promiseSomething(step1);

// Навешиваем callback
promise.then(function() {
	console.log('Получилось!!!11');
});
</code>
		</pre>
	</div>
</section>

<section class="slide">
	<h2>Состояние Promise</h2>
	<blockquote>
		<p>
			<b>Промисы могут находиться в одном из трёх состояний:</b>
			<ul>
				<li>вначале <strong>pending</strong> («ожидание»)</li>
				<li>затем либо <strong>fulfilled</strong> («выполнено успешно»)</li>
				<li>либо <strong>rejected</strong> («выполнено с ошибкой»)</li>
			</ul>
		</p>
	</blockquote>
	<div style="position:relative;width: 100%; height: 40%;">
		<img class="place" src="promiseInit.png" style="transform-origin: center;transform: translate(-50%,-50%) scale(1.6);">
	</div>
</section>

<section class="slide">
	<!--
	Этот небольшой трюк дарит нам много возможностей
	для организации нашего асинхронного кода

	Перечисляю и рассказываю первые три пункта, на последнем скипаю к след слайду
	-->
	<h2>Какая польза от промисов?</h2>
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%;">
		<ul>
			<li>Можно навешивать несколько обработчиков событий</li>
			<li>Можно делиться обещаниями с другими частями системы</li>
			<li>Можно навесить обработчик события потом</li>
			<li>Можно строить цепочки асинхронных вызовов без callback hell</li>
		</ul>
	</div>
</section>

<!--
	Еще раз подробно на примере рассказываю как работает then

	В особенности возвращение другого промиса из колбека
	-->
<section class="slide">
	<h2>Избавляемся от callback hell</h2>
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%;">
		<pre class="hljs js">
<code>
// Делаем что-нибудь асинхронное
promiseSomething().then(function() {
	// Затем делаем еще что-нибудь важное
	return promiseSomethingElse();
}).then(function() {
	// Финальный callback
	console.log('Получилось!!!11');
});
</code>
		</pre>
	</div>
</section>

<section class="slide">
	<!--
		Так же промисы позволяют проще делать некоторые часто требуемые операции.
		Например выполнить все запросы параллельно можно с помощью статичного метода Promise.all

		Объясняю Promise.all
	-->
	<h2>Promise.all</h2>
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%;">
		<pre class="hljs js">
<code>
// Делаем что-нибудь асинхронное
// и важное одновременно
Promise.all([
	promiseSomething(),
	promiseSomethingElse()
]).then(function(result) {
	// Результатом станет массив из значений всех обещаний
	result.forEach(function(value, i) {
		console.log(`Результат ${i}: ${value}`);
	});
});
</code>
		</pre>
	</div>
</section>

<section class="slide">
	<h2>Promise.race</h2>
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%;">
		<pre class="hljs js">
<code>
// Делаем что-нибудь асинхронное
// и важное на перегонки!
Promise.race([
	promiseSomething(),
	promiseSomethingElse()
]).then(function(result) {
	// Результатом станет значение самого "быстрого" промиса
	console.log(`Результат: ${value}`);
});
</code>
		</pre>
	</div>
</section>

<section class="slide">
	<h2>Как создать Promise?</h2>
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%;">
		<pre class="hljs js">
			<code>const promise = new Promise(function(resolve, reject) {</code>
			<code>    <span class="comment rus">// Здесь можно выполнять любые действия</span></code>
			<code> </code>
			<code>    <span class="comment rus">// вызов resolve(result) переведёт промис в состояние <mark>fulfilled</mark></span></code>
			<code>    <span class="comment rus">// вызов reject(error) переведёт промис в состояние <mark>rejected</mark></span></code>
			<code>});</code>
			<code> </code>
		</pre>
	</div>
</section>

<section class="slide">
	<h2>Промисификация</h2>
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%;">
		<pre class="hljs js">
<code>

// Обещаем сделать что-нибудь асинхронное
function promiseSomething(callback) {
	return new Promise(function(resolve) {
		// Делаем что-нибудь асинхронное
		doSomething(resolve);
	});
}
</code>
		</pre>
	</div>
</section>

<section class="slide">
	<h2>Как создать Promise?</h2>
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%;">
		<pre class="hljs js">
			<code><span class="comment rus">// Можно создать сразу "готовый" промис</span></code>
			<code>const fulfilled = Promise.resolve(result);</code>
			<code>// const fulfilled = new Promise((resolve, _) => resolve(result));</code>
			<code>const rejected = Promise.reject(error);</code>
			<code>// const rejected = new Promise((_, reject) => reject(error));</code>
		</pre>
	</div>
</section>

<section class="slide">
	<h2>Fetch API</h2>
	<blockquote>
		<p>
			Метод <mark>fetch</mark> – это <mark>XMLHttpRequest</mark> нового поколения.
			Он предоставляет улучшенный интерфейс для осуществления запросов к серверу:
			как по части возможностей и контроля над происходящим,
			так и по синтаксису, так как построен на <b>промисах</b>.
		</p>
	</blockquote>
	<div style="display: flex; justify-content: center; align-items: center; width: 100%;">
			<pre class="hljs js">
				<code>// Синтаксис метода fetch:</code>
				<code>let promise = fetch(url[, options]);</code>
			</pre>
	</div>
</section>

<section class="slide">
	<h2>Fetch API</h2>
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%;">
			<pre class="hljs js">
				<code>
				fetch('/books')
				  .then(function(response) {
					// Получаем ответ, но еще не содержимое
					// можем проверить информацию из заголовков:
					console.log(response.headers.get('Content-Type'));
					console.log(response.status);

					// Парсим тело ответа
					return response.json();
				   })
				  .then(function(books) {
					// Получаем наконец содержимое ответа
					console.log(books);
				  });
				</code>
			</pre>
	</div>
</section>

<!--закончили с Promise и Fetch API-->


<section class="slide">
	<h2 class="shout">Перехват ошибок</h2>
</section>


<!--
Никто не идеален, ошибки случаются

объясняю что происходит

рассказываю о том что качество последующего кода
не влияет на то иполнится он или нет

это не значит что нужно писать код без ошибок
ошибка может произойти по независящим от нас причинам
-->
<section class="slide">
	<h2>Try, catch</h2>
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%;">
		<pre class="hljs js">
			<code>

console.log('Получится');

const foo = bar; // ReferenceError: bar is not defined

console.log('Не получится');

			</code>
		</pre>
	</div>
</section>

<!--
Для обработки исключения в JavaScript как и в многих других языках
есть специальная конструкция try catch
-->
<section class="slide">
	<h2>Try, catch</h2>
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%;">
		<pre class="hljs js">
			<code>
try {

  // код

} catch (err) {

  // обработка ошибки

}
			</code>
		</pre>
	</div>
</section>

<section class="slide">
	<h2>Try, catch</h2>
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%;">
		<pre class="hljs js">
			<code>
try {

  // Выбрасываем исключение вручную
  throw "Привет, я ошибка!";

} catch (err) {

  alert(err); // Привет, я ошибка!

}
			</code>
		</pre>
	</div>
</section>

<section class="slide">
	<h2>Асинхронные ошибки</h2>
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%;">
		<pre class="hljs js">
			<code>
try {

	setTimeout(function() {
		throw "Я ошибка из будещего";
	}, 1000);

} catch (err) {

	alert(err); // Не выполнится

}
			</code>
		</pre>
	</div>
</section>

<section class="slide">
	<h2>promise.catch()</h2>
	<div style="display: flex; justify-content: center; align-items: center; height: 600px; width: 100%;">
		<pre class="hljs js">
			<code>
const promise = delay(1000).then(function() {
	throw "Я ошибка из будещего";
});

promise.catch(function(err) {
	alert(err);// Я ошибка из будещего
});
			</code>
		</pre>
	</div>
</section>

<!--закончили с исключениями-->

<section class="slide">
	<h2 class="shout">Тестирование</h2>
</section>

<section class="slide">
    <h2>Каким бывает тестирование?</h2>
    <img class="place" src="testing1.png" height="500">
</section>

<section class="slide">
    <h2>Юнит-тестирование</h2>
	<br/>
    <blockquote>
        <p>
            Модульное тестирование</b>, или <b>юнит-тестирование</b> (англ. unit testing) —
            процесс в программировании, позволяющий проверить на корректность отдельные
            модули исходного кода программы.
        </p>
        <p>
            Идея состоит в том, чтобы писать тесты для каждой нетривиальной функции или метода.
            Это позволяет достаточно быстро проверить, не привело ли очередное
            изменение кода к регрессии, то есть к появлению ошибок в уже оттестированных
            местах программы, а также облегчает обнаружение и устранение таких ошибок.
        </p>
    </blockquote>
</section>

<section class="slide">
    <h2>Что тестировать?</h2>
    <img class="place" src="testing_code.png" height="500">
</section>



<!--закончили с Тестированием?-->


<section class="slide">
	<h2>Полезные ссылки</h2>
	<ul lang="en">
		<li>Same-origin policy описано <a
				href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy" target="_blank">здесь
			(MDN)</a> и
			<a href="https://en.wikipedia.org/wiki/Same-origin_policy" target="_blank">здесь (wiki)</a></li>
		<li>Метода обхода Same-origin policy <a
				href="http://stackoverflow.com/questions/3076414/ways-to-circumvent-the-same-origin-policy"
				target="_blank">stackoverflow</a></li>
		<li>Iframe: <a href="https://webref.ru/html/iframe" target="_blank">WebReference.ru</a> и <a
				href="https://learn.javascript.ru/same-origin-policy" target="_blank">learn.javascript.ru</a></li>
		<li>Кроссдоменные запросы на <a href="https://learn.javascript.ru/xhr-crossdomain" target="_blank">learn.javascript.ru</a>
		</li>
		<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank">Описание</a>
			HTTP access control (CORS)
		</li>
		<li>Документация к <strong>Spring</strong> про CORS: <a
				href="https://spring.io/blog/2015/06/08/cors-support-in-spring-framework" target="_blank">здесь</a></li>
		<li>API (application programming interface) <a
				href="https://en.wikipedia.org/wiki/Application_programming_interface" target="_blank">wiki</a></li>
		<li>Документирование API с помощью <a href="http://swagger.io/" target="_blank">swagger</a>, <a
				href="https://apiary.io/" target="_blank">apiary</a> или <a href="https://apiblueprint.org/"
																			target="_blank">apiblueprint</a></li>
	</ul>
</section>

<section class="slide">
	<h2>Полезные ссылки</h2>
	<ul lang="en">
		<li>Семантический API: <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" target="_blank">CRUD</a>
			и
			<a href="http://www.ibm.com/developerworks/ru/library/ws-restfu/" target="_blank">REST</a></li>
		<li>Тестирование JavaScript <a href="https://jasmine.github.io/" target="_blank">с помощью Jasmine</a></li>
		<li>Очень подробные посты, про Promise на <a href="https://learn.javascript.ru/promise" target="_blank">learn.javascript.ru</a>
			и на
			<a href="https://habrahabr.ru/post/209662/" target="_blank">хабре</a></li>
		<li><a href="https://learn.javascript.ru/fetch" target="_blank">Fetch API</a></li>
	</ul>
</section>

<section class="slide">
	<h2 class="shout">Всем спасибо!</h2>
</section>

<div class="progress"></div>
<script src="/lib/shower/shower.min.js"></script>
<script src="/lib/hljs/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

</body>
</html>
